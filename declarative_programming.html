<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AncientStraits</title>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs.min.css">
    <link rel="stylesheet" href="style/style.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll()</script>
</head>
<body>
    <header><a href=index.html>
        AncientStraits
    </a></header>
    <div class="post">
        <h1 class="title">Declarative Programming</h1>
        <h2 class="date">2 Jun 2022 at 12:35 PM</h2>
        <hr>
        <div class="content">
            <p>The reader (that is you) must have learnt about declarative programming.
In my quest to write a programming video generator named Codim,
I have thought about declarative programming and how it could change my library's API.</p>
<h1>What is Declarative Programming?</h1>
<p>Declarative programming is when you tell the computer to perform an action,
instead of telling it to perform the steps in that action.
This means that functions can be a type of declarative structure.
For example, in Codim:</p>
<pre><code class="language-c">static AVFrame* create_video_frame(AVCodecContext* vcc) {
    AVFrame* ret = av_frame_alloc();

    ret-&gt;format = vcc-&gt;pix_fmt;
    ret-&gt;width  = vcc-&gt;width;
    ret-&gt;height = vcc-&gt;height;
    av_frame_get_buffer(ret, 0);

    return ret;
}

void output_context_open(OutputContext* oc) {
    // ...
    oc-&gt;vf = create_video_frame(oc-&gt;vcc);
    // ...
}
</code></pre>
<p>The line starting with <code>oc-&gt;vf</code> could be called "declarative programming" because it just
tells a computer to let <code>oc-&gt;vf</code> be a video frame based on <code>oc-&gt;vcc</code>'s settings.</p>
<h1>"Markup-style" declarative programming</h1>
<p>Although my example could be considered declarative, the reader (you again) probably thinks
that it's still primarily imperative, because it's using an imperative library in an
imperative programming language. The reader's first thought when hearing the word
"declarative programming" might be a React component:</p>
<pre><code class="language-js">const MyComponent = ({time}) =&gt; (
    &lt;div style={{color: 'blue'}}&gt;
        &lt;h1&gt;The Time&lt;/h1&gt;
        &lt;p&gt;The time is {time}.&lt;/p&gt;
    &lt;/div&gt;
)
</code></pre>
<p>In this case, <code>MyComponent</code> is declarative because it is returning the UI,
instead of telling some context to change each property.
The result is something a lot like markup, but in a programming language.
The opposite of this is the JavaScript canvas API:</p>
<pre><code class="language-js">ctx.fillStyle = '#123456'
ctx.fillRect(12, 34, 56, 78)
</code></pre>
<p>The UI is not being returned all at once, and is being applied to a context.</p>
<h1>The Significance of Declarative Programming in Animation</h1>
<p>Although it wouldn't hurt to write the canvas code above instead of using a React component,
it gets much worse when trying to draw something animated:</p>
<pre><code class="language-js">let x = 0;
const loop = () =&gt; {
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.fillRect(x, 100, 20, 20)
    x++
    requestAnimationFrame(loop)
}
</code></pre>
<p>Definitely not something you can return. This could also not use iteration/recursion if the API stored the current time. Then it could all be declarative.</p>
<pre><code class="language-js">const Rect = () =&gt; {
    const frame = useCurrentFrame()
    return (&lt;svg&gt;
        &lt;rect x={frame} y=&quot;100&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;
    &lt;/svg&gt;)
}
</code></pre>
<p>The above example is easy to understand because it just makes a vector of a rect with its
x value assigned to the frame number. No looping, which is done internally by the framework.
Speaking of the framework, the above code is actually valid syntax for Remotion, an animation
generator that uses React to render videos. I am not using it and instead wasting 8 months writing Codim because Remotion takes up an extreme amount of space for a single project, unlike 3Blue1Brown's Manim, which is just a binary that takes a single Python file as input.
Why am I not using Manim either? Because it's written mainly for math animations, not my niche.</p>
<h1>Declarative Programming in Codim</h1>
<p>Codim will use LuaJIT for scripting, because Lua is very light and LuaJIT is faster than Node.
It it easy to maintain a declarative syntax in a scripting language like Lua.
One idea I have for the API is this:</p>
<pre><code class="language-lua">local cm = require('codim')

function rect()
    return cm.rect {
        x = cm.frame,
        y = 100,
        width  = 20,
        height = 20,
    }
end

function main()
    return cm.frame &lt;= 5 and cm.output{
        width  = 1920,
        height = 1080,
        fps    = 24,
        rect{},
    } or nil
end
</code></pre>
<p>The above code sample takes advantage of many things in Lua:</p>
<ul>
<li>Lua's <code>and / or</code> functions like a ternary statement, so we can use it to set the length of a video. In this case, the video is 5 seconds long. The video will end once <code>nil</code> is returned.</li>
<li>In Lua, whenever a function is called with one string or one table, the parentheses in the function call are optional. This means that <code>fn('abc')</code> and <code>fn 'abc'</code> are the same, as well as <code>fn({a = 1})</code> and <code>fn{a = 1}</code>. This can save clutter when writing components.</li>
<li>Lua's tables (<code>{}</code>) are the only non-scalar data structure, so they are both objects and arrays. Whenever the key isn't specified in an array, like <code>rect{}</code> in <code>main</code>, it will get assigned to an integer index, starting from 1. This means that the key of <code>rect{}</code> implicitly is 1. By assuming that a component's properties are string indices and a component's children are at integer indices, we can easily specify both the properties and children in one table.</li>
</ul>
<h1>Declarative Is Not Always Better</h1>
<p>While the above example of declarative programming might seem nice, it might be bad when we want to render multiple things in succession. One would have to do some magic to make sure everything comes one after another in time. In this case, imperative animation succeeds.
Take an example from Manim, which uses a more imperative API:</p>
<pre><code class="language-py">class SquareToCircle(Scene):
    def construct(self):
        circle = Circle()  # create a circle
        circle.set_fill(PINK, opacity=0.5)  # set color and transparency

        square = Square()  # create a square
        square.rotate(PI / 4)  # rotate a certain amount

        self.play(Create(square))  # animate the creation of the square
        self.play(Transform(square, circle))  # interpolate the square into the circle
        self.play(FadeOut(square))  # fade out animation
</code></pre>
<p>Although React users would call this imperative, I really think it is more declarative than React. In this code sample, it is very easy to understand what will happen. A square rotated 45 degrees counterclockwise will be created, then will be animated into a pink, transparent circle, which will fade out. Notice that there are no dimensions or time measurement here - the only numbers are <code>PI / 4</code> and <code>0.5</code>. The programmer is telling the computer to perform an action instead of telling it how to, then trusting it to generate something suitable. This is the definition of declarative I defined at the start of this post. The programmer does not have to write any complicated components that vary dependent on time, that programmer just has to trust Manim that it will make a good video.</p>
<h1>The Quality of the Videos</h1>
<p>The Python sample above creates <a href="https://docs.manim.community/en/stable/tutorials/SquareToCircle2-1.mp4">the video here</a>. Notice how much has been defined by the library itself - and for the better. The most beautiful generated videos are made declaratively, where the polish can be added in the library implementation. Once it is added, it becomes the reason that 3Blue1Brown's YouTube videos look so spectacular. It not only creates something good, but the code also looks good. This has to be the best fit for Codim - to let most things be as declarative as possible, so that there is as much potential to make beautiful videos as possible.</p>
        </div>
    </div>
</body>
</html>
